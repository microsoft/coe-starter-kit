# This is a deployment template referenced from build-deploy-Solution.yml

# build-deploy-Solution.yml calls this template twice, passing different connection information for test vs prod
parameters:
- name: serviceConnection
  type: string
- name: environmentVariables
  type: string
- name: connectionReferences
  type: string
- name: aadGroupTeamConfiguration
  type: string
- name: aadGroupCanvasConfiguration
  type: string
- name: solutionComponentOwnershipConfiguration
  type: string
- name: importUnmanaged
  type: string
  default: 'false'
steps:
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.tool-installer.PowerPlatformToolInstaller@0
  displayName: 'Install Power Platform Build Tools'

# TEMPORARY: using Power DevOps Tools to supplement official Power Platform Build Tools until they have tasks which enable the same scenarios.
# https://marketplace.visualstudio.com/items?itemName=WaelHamze.xrm-ci-framework-build-tasks
- task: WaelHamze.xrm-ci-framework-build-tasks.MSCRMToolInstaller.MSCRMToolInstaller@12
  displayName: 'Power DevOps Tool Installer'

- template: install-powershell-modules.yml

# Other tasks, which use the PowerApps PowerShell cmdlets, need the environment guid.  Setting it for future use.
- template: set-environment-id.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'

# Other tasks, in this pipeline need to know if the solution already exists. Setting it for future use.
- template: set-solution-exists.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'

# Get the solution package from artifact uploaded by the build pipeline
- task: DownloadPipelineArtifact@2
  displayName: 'Download Build Pipeline Artifact'

# If called from import-unmanaged-to-dev-environment.yml, this task will run to deploy an unmanaged solution
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Unmanaged Solution'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: '$(UnmanagedSolutionPath)'
    PublishWorkflows: true
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))

- powershell: |
   $managedSolutionPath = ''
   $buildDropExists = 'false'
   If (Test-Path -Path "$(Pipeline.Workspace)/buildPipeline/drop")
   {
       $buildDropExists = 'true'
       #Attempt to find the managed solution in the build pipeline drop if build and deploy are seperate pipelines
       Get-ChildItem -Path "$(Pipeline.Workspace)/buildPipeline/drop" -Filter "$(SolutionName)*.zip" | 
       ForEach-Object {
           If ($_.FullName.Contains("_managed")) 
           { 
             $managedSolutionPath = $_.FullName 
           }
       }
   }
   If ($managedSolutionPath -eq '')
   {
        #Default to managed solution path in the same pipeline if using build-deploy-Solution.yml
        $managedSolutionPath = '$(Pipeline.Workspace)/drop/$(SolutionName)_$(Build.BuildNumber)_managed.zip'
   }
   Write-Host "##vso[task.setVariable variable=ManagedSolutionPath]$managedSolutionPath"
   Write-Host "##vso[task.setVariable variable=BuildDropExists]$buildDropExists"
   Write-Host $managedSolutionPath
  displayName: 'Get managed solution zip path'
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'))

# Task will read the json file from the Pipeline Artifact and populate the value of the variables from the build pipeline for PRs and for Solution Upgrade
- task: nkdagility.variablehydration.variablerehydration-task.variablerehydration@0
  displayName: 'Load Variables from drop'
  inputs:
    jsonfiles: '$(Pipeline.Workspace)/buildPipeline/drop/meta-*.json'
  condition: and(succeeded(), eq(variables['BuildDropExists'], 'true'), ne('${{parameters.importUnmanaged}}', 'true'))
  continueOnError: true 

# If the TriggerSolutionUpgrade variable is false, then import the solution as an Update
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Update'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    PublishWorkflows: true
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), or(eq(variables['TriggerSolutionUpgrade'], 'false'), eq(variables['SolutionExists'], 'False')))

# If the TriggerSolutionUpgrade variable is true, then import the solution as an Upgrade, staging it as a holding solution, so we can apply a solution Upgrade.
# Doing this will ensure that items removed from the solution in development are also removed from the solution in the target environment after the Upgrade is applied.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Upgrade'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    HoldingSolution: true
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), eq(variables['TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'True'))

# NOTE: Sometimes you need to perform intermediary steps between staging the upgrade and applying it.  
# An example would be moving data from one entity to another before deleting the entity.
# You would add steps to your pipeline here to accomplish this. 

# If the TriggerSolutionUpgrade variable is true,then apply the solution Upgrade.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.apply-solution-upgrade.PowerPlatformApplySolutionUpgrade@0
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionName: '$(SolutionName)'
    AsyncOperation: true
  condition: and(succeeded(), eq(variables['TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'True'))

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.publish-customizations.PowerPlatformPublishCustomizations@0
  displayName: 'Power Platform Publish Customizations '
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))
  # Only publish customizations for when importing unmanaged solutions into a dev environment.

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outEnvironmentVariables;isOutput=true]${{parameters.environmentVariables}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outEnvironmentVariables;isOutput=true]"
    }
  name: setEnvironmentVariablesOutput
  displayName: 'Set Environment Variables for Condition'

# WORKAROUND: We were using parameters in the condition, but it was not evaluating.  Reviewed: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=yaml#use-a-template-parameter-as-part-of-a-condition
# Current workaround is to set an output variable in the step above and use that in the condition below.
# Not sure this is the best way, but it works.
# Replace with official task when available
- task: WaelHamze.xrm-ci-framework-build-tasks.MSCRMUpdateEnvironmentVariables.MSCRMUpdateEnvironmentVariables@12
  displayName: 'Update Environment Variables'
  inputs:
    crmConnectionString: '$(CdsBaseConnectionString)${{parameters.serviceConnection}}'
    environmentVariablesJson: '${{parameters.environmentVariables}}'
  condition: and(succeeded(), ne(variables['setEnvironmentVariablesOutput.outEnvironmentVariables'], ''))

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outConnectionReferences;isOutput=true]${{parameters.connectionReferences}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outConnectionReferences;isOutput=true]"
    }

  name: setConnectionReferencesOutput
  displayName: 'Set Connection References for Condition'

- template: update-connection-references.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    connectionReferences: '${{parameters.connectionReferences}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outAadGroupTeamConfiguration;isOutput=true]${{parameters.aadGroupTeamConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outAadGroupTeamConfiguration;isOutput=true]"
    }
  name: setAadGroupTeamConfigurationOutput
  displayName: 'Set AAD Group Team Configuration for Condition'

- template: set-dataverse-aad-group-teams.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    aadGroupTeamConfiguration: '${{parameters.aadGroupTeamConfiguration}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outAadGroupCanvasConfiguration;isOutput=true]${{parameters.aadGroupCanvasConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outAadGroupCanvasConfiguration;isOutput=true]"
    }
  name: setAadGroupCanvasConfigurationOutput
  displayName: 'Set AAD Group Canvas Configuration for Condition'

- template: share-canvas-app-with-aad-group.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    aadGroupCanvasConfiguration: '${{parameters.aadGroupCanvasConfiguration}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outSolutionComponentOwnershipConfiguration;isOutput=true]${{parameters.solutionComponentOwnershipConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outSolutionComponentOwnershipConfiguration;isOutput=true]"
    }
  name: setSolutionComponentOwnershipConfigurationOutput
  displayName: 'Set Solution Component Ownership Configuration for Condition'

- template: update-solution-component-ownership.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    solutionComponentOwnershipConfiguration: '${{parameters.solutionComponentOwnershipConfiguration}}'

- template: import-configuration-migration-data.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'